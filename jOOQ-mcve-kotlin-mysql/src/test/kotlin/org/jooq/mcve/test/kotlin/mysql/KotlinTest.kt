package org.jooq.mcve.test.kotlin.mysql

import org.jooq.DSLContext
import org.jooq.Records
import org.jooq.SQLDialect
import org.jooq.exception.MappingException
import org.jooq.impl.DSL
import org.jooq.mcve.kotlin.mysql.tables.Film.Companion
import org.jooq.mcve.kotlin.mysql.tables.pojos.Actor
import org.jooq.mcve.kotlin.mysql.tables.pojos.Film
import org.jooq.mcve.kotlin.mysql.tables.pojos.FilmActor
import org.jooq.mcve.kotlin.mysql.tables.records.ActorRecord
import org.jooq.mcve.kotlin.mysql.tables.records.FilmActorRecord
import org.jooq.mcve.kotlin.mysql.tables.records.FilmRecord
import org.jooq.mcve.kotlin.mysql.tables.references.ACTOR
import org.jooq.mcve.kotlin.mysql.tables.references.FILM
import org.jooq.mcve.kotlin.mysql.tables.references.FILM_ACTOR
import org.jooq.mcve.kotlin.mysql.tables.references.TEST
import org.jooq.tools.JooqLogger
import org.junit.*
import org.junit.Assert.*
import org.testcontainers.containers.MySQLContainer
import org.testcontainers.utility.ResourceReaper
import sight.mvce.FilmWithActor
import java.sql.Connection
import java.sql.DriverManager

class KotlinTest {
    companion object {
        var log: JooqLogger = JooqLogger.getLogger(KotlinTest::class.java)
        var db: MySQLContainer<*>? = null
        var connection: Connection? = null
        var ctx: DSLContext? = null

        @BeforeClass
        @JvmStatic
        fun init() {
            if (System.getProperty("jooq.codegen.jdbc.url") == null) {
                db = MySQLContainer("mysql:latest")
                    .withUsername("root")
                    .withPassword("")
                    .withInitScript("db/migration/init.sql")
                db!!.start()
                System.setProperty("jooq.codegen.jdbc.url", db!!.jdbcUrl)
                System.setProperty("jooq.codegen.jdbc.username", db!!.username)
                System.setProperty("jooq.codegen.jdbc.password", db!!.password)
            }

            log.info("Connecting")
            connection = DriverManager.getConnection(
                System.getProperty("jooq.codegen.jdbc.url"),
                System.getProperty("jooq.codegen.jdbc.username"),
                System.getProperty("jooq.codegen.jdbc.password")
            )
            ctx = DSL.using(connection, SQLDialect.MYSQL)
            connection!!.createStatement().use { s -> log.info("Finished setup") }
        }

        @AfterClass
        @JvmStatic
        fun end() {
            if (db != null) {
                ResourceReaper.instance().stopAndRemoveContainer(db!!.containerId, db!!.dockerImageName)
            }
        }
    }

    @Before
    fun setup() {
        ctx().delete(TEST).execute()
    }

    @After
    fun after() {
    }

    fun ctx(): DSLContext = ctx!!

    @Test
    fun mcveTest() {
        assertEquals(
            1, ctx()
                .insertInto(TEST)
                .columns(TEST.CD)
                .values(42)
                .execute()
        )

        val record = ctx().fetchOne(TEST, TEST.CD.eq(42))
        assertNotNull(record?.id)
    }

    @Test
    fun `SUCCESS - With Explicit Path Join & with no java reflection`() {
        val FILM = FILM

        // when
        val results: List<FilmWithActor> = ctx().select(
            FILM,
            FILM.filmActor,
            FILM.filmActor.actor,
        )
            .from(FILM)
            .join(FILM.filmActor)
            .join(FILM.filmActor.actor)
            .fetch(Records.mapping(::filmWithActorMapper))

        // then
        assertNotNull(results[0].film)
        assertNotNull(results[0].filmActor)
        assertNotNull(results[0].actor)
    }

    private fun filmWithActorMapper(
        filmRecord: FilmRecord,
        filmActorRecord: FilmActorRecord,
        actorRecord: ActorRecord
    ): FilmWithActor {
        return FilmWithActor(
            film = Film().apply { filmRecord.into(this) },
            filmActor = FilmActor().apply { filmActorRecord.into(this) },
            actor = Actor().apply { actorRecord.into(this) },
        )
    }

    @Test
    fun `SUCCESS - Without Explicit Path Join & With fetchInto`() {
        val FILM = FILM
        val FILM_ACTOR = FILM_ACTOR
        val ACTOR = ACTOR

        // when
        val results: List<FilmWithActor> = ctx().select(
            FILM,
            FILM_ACTOR,
            ACTOR
        )
            .from(FILM)
            .join(FILM_ACTOR).on(FILM_ACTOR.FILM_ID.eq(FILM.FILM_ID))
            .join(ACTOR).on(ACTOR.ACTOR_ID.eq(FILM_ACTOR.ACTOR_ID))
            .fetchInto(FilmWithActor::class.java)

        // then
        assertNotNull(results[0].film)
        assertNotNull(results[0].filmActor)
        assertNotNull(results[0].actor)
    }

    @Test
    fun `FAIL - With Explicit Path Join & With fetchInto`() {
        val FILM = FILM

        // when & then
        assertThrows(MappingException::class.java) {
            ctx().select(
                FILM,
                FILM.filmActor, // this will cause NPE, since alias goes 'alias_xxx' (not filmActor)
                FILM.filmActor.actor, // this will cause NPE, since alias goes 'alias_xxx' (not actor)
            )
                .from(FILM)
                .join(FILM.filmActor)
                .join(FILM.filmActor.actor)
                .fetchInto(FilmWithActor::class.java)
        }
    }

    @Test
    fun `SUCCESS - With Explicit Path Join & With fetchInto & alias mapping explicitly`() {
        val FILM = FILM

        // when
        val results: List<FilmWithActor> = ctx().select(
            FILM,
            FILM.filmActor.`as`("filmActor"), // this will not cause NPE, since alias goes 'filmActor'
            FILM.filmActor.actor.`as`("actor"), // this will not cause NPE, since alias goes 'actor'
        )
            .from(FILM)
            .join(FILM.filmActor.`as`("filmActor"))
            .join(FILM.filmActor.actor.`as`("actor"))
            .fetchInto(FilmWithActor::class.java)

        // then
        assertNotNull(results[0].film)
        assertNotNull(results[0].filmActor)
        assertNotNull(results[0].actor)
    }
}
